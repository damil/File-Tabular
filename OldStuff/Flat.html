<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>File::Flat - utilities for working with flat files</title>
<link rev="made" href="mailto:" />
</head>

<body style="background-color: white">

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<li><a href="#methods">METHODS</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<hr />
<h1><a name="name">NAME</a></h1>
<p>File::Flat - utilities for working with flat files</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>
</p>
<hr />
<h1><a name="methods">METHODS</a></h1>
<dl>
<dt><strong><a name="item_new">new (openparams, args)</a></strong><br />
</dt>
<dl>
<dt><strong><a name="item_openparams">openparams</a></strong><br />
</dt>
<dd>
List of arguments for opening the file ; these will 
be fed directly to <em>perlfunc</em>. Can also be a reference
to an already opened filehandle.
</dd>
<p></p>
<dt><strong><a name="item_args">args</a></strong><br />
</dt>
<dd>
a reference to a hash containing following keys :
</dd>
<dl>
<dt><strong><a name="item_fieldsep">fieldSep</a></strong><br />
</dt>
<dd>
field separator ('|' by default)
</dd>
<p></p>
<dt><strong><a name="item_recordsep">recordSep</a></strong><br />
</dt>
<dd>
record separator ('\n' by default)
</dd>
<p></p>
<dt><strong><a name="item_fieldseprepl">fieldSepRepl</a></strong><br />
</dt>
<dd>
string to substitute if fieldSep is met in the data.
(by default, url encoding of <strong>fieldSep</strong>, i.e. '%7C' )
</dd>
<p></p>
<dt><strong><a name="item_recordseprepl">recordSepRepl</a></strong><br />
</dt>
<dd>
string to substitute if recordSep is met in the data 
(by default, url encoding of <strong>recordSep</strong>, i.e. '%0A' )
</dd>
<p></p>
<dt><strong><a name="item_autonumfield">autoNumField</a></strong><br />
</dt>
<dd>
name of field for which autonumbering is turned on (none by default).
This is useful to generate keys : when 
you write a record, the character '#' in that field will be
replaced by a fresh number, incremented automatically.
Initial value of the counter 1 + the largest number read
<em>so far</em> (it is your responsability to read all records
before the first write operation).
</dd>
<p></p>
<dt><strong><a name="item_autonummax">autoNumMax</a></strong><br />
</dt>
<dd>
initial value of the counter for autonumbering (1 by default).
</dd>
<p></p>
<dt><strong><a name="item_autonumchar">autoNumChar</a></strong><br />
</dt>
<dd>
character that will be substituted by an autonumber when
writing records ('#' by default).
</dd>
<p></p>
<dt><strong><a name="item_flockmode">flockMode</a></strong><br />
</dt>
<dd>
mode for locking the file, see <em>perlfunc</em>. By default,
this will be LOCK_EX if <strong>openargs</strong> contains '&gt;' or
'+&lt;', LOCK_SH otherwise.
</dd>
<p></p>
<dt><strong><a name="item_flockattempts">flockAttempts</a></strong><br />
</dt>
<dd>
Number of attempts to lock the file,
at 1 second intervals, before returning an error.
Zero by default.
If nonzero, LOCK_NB is added to flockMode;
if zero,  a single locking attempt will be made, blocking
until the lock is available.
</dd>
<p></p>
<dt><strong><a name="item_headers">headers</a></strong><br />
</dt>
<dd>
reference to an array of field names.
If not present, headers will be read from the first line of
the file.
</dd>
<p></p>
<dt><strong><a name="item_printheaders">printHeaders</a></strong><br />
</dt>
<dd>
if true, the <strong>headers</strong> will be printed to the file.
If not specified, treated as 'true' if
<strong>openargs</strong> contains '&gt;'.
</dd>
<p></p>
<dt><strong><a name="item_journal">journal</a></strong><br />
</dt>
<dd>
name of journaling file, or reference to a list of arguments
for <em>perlfunc</em>. The journaling file will log all write operations.
If specified as a file name, will be  be opened in '&gt;&gt;' mode.
</dd>
<p></p></dl>
</dl>
<dt><strong><a name="item_fetchrow"><code>fetchrow(query)</code></a></strong><br />
</dt>
<dd>
returns the next record matching the (optional) query. 
If there is no query, just returns the next record.
</dd>
<p></p>
<dt><strong><a name="item_fetchall">fetchall(query, @keys)</a></strong><br />
</dt>
<dd>
finds all next records matching the (optional) query.
Keys are also optional. Return value depends on 
context and on the <strong>@keys</strong> argument :
</dd>
<ul>
<li></li>
if <strong>@keys</strong> is empty, and we are in a scalar context, then
it returns a reference to an array of records
matching the query (or, if there is no query, of all remaining records).
<p></p>
<li></li>
if <strong>@keys</strong> is not empty, and we are in a scalar contect, then
it returns a reference to a hash. 
Keys of the hash are built by taking one or several values 
from the records, according to the list of field names in <strong>@keys</strong>;
if this list has more than one name, then the values are concatenated
according to <em>perlvar</em>.
Obviously, values of the hash are references to those records.
<p></p>
<li></li>
if we are in a list context, then
it returns a pair : first item is a reference to an array or a hash, 
depending on <strong>@keys</strong> as described above;
second item is a reference to an array of line numbers
corresponding to those records (first dataline has number 0).
<p></p></ul>
<dt><strong><a name="item_rewind">rewind</a></strong><br />
</dt>
<dd>
Rewinds the file to the first data line (after the headers)
</dd>
<p></p>
<dt><strong><a name="item_clear">clear</a></strong><br />
</dt>
<dd>
removes all datalines (but keeps the header line)
</dd>
<p></p>
<dt><strong>headers</strong><br />
</dt>
<dd>
returns the list of field names
</dd>
<p></p>
<dt><strong><a name="item_splices">splices</a></strong><br />
</dt>
<dd>
<pre>
  splices(pos1 =&gt; 2, undef,           # delete 2 lines
          pos2 =&gt; 1, row,             # replace 1 line
          pos3 =&gt; 0, [row1, row2 ...] # insert lines
              ...
          -1   =&gt; 0, [row1, ...     ] # append lines
           );</pre>
</dd>
<dd>
<pre>
           # special case : autonum if pos== -1</pre>
</dd>
<dd>
<p>rewrites the whole file, deleting, replacing or appending data lines.
Returns the number of ``splice instructions'' performed.
Splice instructions can also be passed as an array ref instead of a list.
Positions always refer to line numbers in the original file, before 
any modifications. Therefore, it makes no sens to write</p>
</dd>
<dd>
<pre>
  splices(10 =&gt; 5, undef,     
          12 =&gt; 0, $myRow)</pre>
</dd>
<dd>
<p>because after deleting 5 rows at line 10, we cannot insert a new
row at line 12.</p>
</dd>
<dt><strong><a name="item_append">append($row1, $row2, ...)</a></strong><br />
</dt>
<dd>
a shorthand for
</dd>
<dd>
<pre>
  splices([-1 =&gt; 0, [$row1, $row2, ...]])</pre>
</dd>
<p>1;</p>
</dl>

</body>

</html>
